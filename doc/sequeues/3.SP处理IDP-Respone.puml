@startuml
Client->ApplicationChain
ApplicationChain->FilterChainProxy:
FilterChainProxy->FilterChainProxy:getFilters(fwRequest)\n匹配内层filters,proxy内部有三个filter,\n这个会匹配出一个就是后面这个
FilterChainProxy->SAMLProcessingFilter:requiresAuthentication(request, response)\n判断是否为认证请求(/saml/SSO),\n如果不认证请求,则可能走第1个流程
SAMLProcessingFilter->SAMLProcessingFilter:attemptAuthentication 尝试认证(包括meta,decode后验签等动作)
SAMLProcessingFilter->SessionAuthenticationStrategy:onAuthentication 认证成功后,判断是否有访问权限
SAMLProcessingFilter->SAMLProcessingFilter:successfulAuthentication以上通过后，将会重定向到资源页面
AnonymousAuthenticationFilter->AnonymousAuthenticationFilter:createAuthentication\n创建匿名认证信息
AnonymousAuthenticationFilter->ExceptionTranslationFilter:进入下一个filter
ExceptionTranslationFilter->FilterSecurityInterceptor:进入安全filter，\n由其判断是否可访问资源
FilterSecurityInterceptor->FilterSecurityInterceptor:invoke(fi)开始处理是否可访问
FilterSecurityInterceptor->FilterSecurityInterceptor:beforeInvocation
FilterSecurityInterceptor->ExpressionBasedFilterInvocationSecurityMetadataSource:getAttributes()\n匹配当前用户(未登匿名用户)\n访问该资源所需的属性
ExpressionBasedFilterInvocationSecurityMetadataSource->FilterSecurityInterceptor:返回访问当前资所需权限属性
FilterSecurityInterceptor->AffirmativeBased:decide() 据认证信息，\n判断是否有访问权限
AffirmativeBased->ExceptionTranslationFilter:无访问权限,抛出的异常被捕获到
ExceptionTranslationFilter->ExceptionTranslationFilter:handleSpringSecurityException\n处理捕获到的异常信息
ExceptionTranslationFilter->ExceptionTranslationFilter:sendStartAuthentication\n发送认证信息
ExceptionTranslationFilter->ConfigurableSAMLEntryPoint:commence()\n saml 开始认证入口
ConfigurableSAMLEntryPoint->ConfigurableSAMLEntryPoint:initializeSSO初始化单点登录
ConfigurableSAMLEntryPoint->WebSSOProfileImpl:sendAuthenticationRequest发送认证请求
WebSSOProfileImpl->WebSSOProfileImpl:getAuthnRequest构建AuthnRequest
WebSSOProfileImpl->WebSSOProfileImpl:sendMessage AuthnRequest构建完成发，准备发送
WebSSOProfileImpl->ConfigurableSAMLProcessor:sendMessage(samlContext,sign)发送前添加配置信息
ConfigurableSAMLProcessor->HTTPPostEncoder:encode 开始encode 成xml格式
HTTPPostEncoder->HTTPPostEncoder:doEncode
HTTPPostEncoder->HTTPPostEncoder:getEndpointURL() 获取授权端(idp)url
HTTPPostEncoder->HTTPPostEncoder:signMessage(samlMsgCtx) 签名授权消息
HTTPPostEncoder->HTTPPostEncoder:postEncode(samlMsgCtx, endpointURL)\n开始利用Velocity模板引擎\n把授权信息生成html格式消息并发给client
HTTPPostEncoder->HTTPPostEncoder:populateVelocityContext \n设置velocityContext变量，\n把AuthRequest转成xml字符串，\n并将xml串base64Encode后\n作为veloctiy $SAMLRequest的值
HTTPPostEncoder->HTTPPostEncoder:velocityEngine 利用上一步信息\n生成html发给client
HTTPPostEncoder->Client:
@enduml
